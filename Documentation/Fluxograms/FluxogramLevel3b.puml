@startuml
skinparam monochrome true
skinparam backgroundColor white

' Start of the process for one day '
start
:Load current day data;
note right: PPV_capacity, P_Load, Cbuy, Csell, ESSparams

' Loop for each time interval (T = 1 to Thorizon) '
:For each T in Thorizon (96 intervals of 15 minutes);

' Prosumer Inputs '
:Get P_Load[T, PL] and PPV_capacity[T, PL];
note right: P_Load = Prosumer usage\nPPV_capacity = Maximum PV production

' Decision on PV energy usage '
:Calculate P_PV_load[T, PL] and P_PV_ESS[T, PL];
note right: P_PV_load + P_PV_ESS = PPV_capacity[T, PL]

' Battery (ESS) Management '
if (P_PV_ESS[T, PL] > 0?) then (Yes)
  :Calculate P_ESS_ch[T, PL];
  note right: P_ESS_ch = P_PV_ESS\nLimited by ESSparams[2, PL] * ESSparams[3, PL]
  :I_ESS_ch[T, PL] = 1;
  :I_ESS_dch[T, PL] = 0;
else (No)
  if (P_Load[T, PL] > P_PV_load[T, PL]?) then (Yes)
    :Calculate P_ESS_dch[T, PL];
    note right: Limited by ESSparams[2, PL] * ESSparams[3, PL]
    :I_ESS_dch[T, PL] = 1;
    :I_ESS_ch[T, PL] = 0;
  else (No)
    :P_ESS_ch[T, PL] = 0;
    :P_ESS_dch[T, PL] = 0;
    :I_ESS_ch[T, PL] = 0;
    :I_ESS_dch[T, PL] = 0;
  endif
endif

' Update battery state of charge '
:Calculate SOC[T, PL];
note right: SOC[T, PL] = SOC[T-1, PL] + Î”T * (ESSparams[1, PL] * P_ESS_ch[T, PL] - P_ESS_dch[T, PL] / ESSparams[1, PL])\nMinimum SOC = ESSparams[4, PL]

' Prosumer Energy Balance '
:Calculate net balance;
note right: P_Load[T, PL] = P_PV_load[T, PL] + P_ESS_dch[T, PL] + P_buy[T, PL] - P_sell[T, PL] + P_peer_in[T, PL] - P_peer_out[T, PL]

' Decision on community exchange '
if (P_Load[T, PL] > P_PV_load[T, PL] + P_ESS_dch[T, PL]?) then (Yes)
  if (Community has available energy?) then (Yes)
    :Receive P_peer_in[T, PL];
    note right: P_peer_in = Energy from another prosumer
  else (No)
    :Buy P_buy[T, PL] from Grid;
    note right: P_buy limited to 12.5 kW\nCost = Cbuy[T] * P_buy[T, PL]
  endif
else (No)
  if (PPV_capacity[T, PL] > P_Load[T, PL] + P_PV_ESS[T, PL]?) then (Yes)
    if (Community needs energy?) then (Yes)
      :Send P_peer_out[T, PL];
      note right: P_peer_out limited by excess PPV_capacity
    else (No)
      :Sell P_sell[T, PL] to Grid;
      note right: P_sell limited to 10.5 kW\nRevenue = Csell[T] * P_sell[T, PL]
    endif
  else (No)
    :P_buy[T, PL] = 0;
    :P_sell[T, PL] = 0;
    :P_peer_in[T, PL] = 0;
    :P_peer_out[T, PL] = 0;
  endif
endif

' Store results for interval T '
:Store P_buy[T, PL], P_sell[T, PL], SOC[T, PL], P_ESS_ch[T, PL], P_ESS_dch[T, PL], P_PV_load[T, PL], P_PV_ESS[T, PL], P_peer_in[T, PL], P_peer_out[T, PL];

' End of time loop '
:Next T;
detach

' End of day '
:Save final SOC for the day;
note right: SOC_end_of_day[PL, day] = SOC[Thorizon, PL]

' Calculate daily objective '
:Calculate total daily cost;
note right: Sum(Cbuy[T] * P_buy[T, PL] - Csell[T] * P_sell[T, PL]) for all T and PL

stop

@enduml